{-|
  Problem 12 of Project Euler

  <http://projecteuler.net/problem=12>

The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?
-}

module Euler.Problem12 where

{-
  Assume there is an answer, so that head does not fail.
-}
firstTriangleNumberOverNDivisors :: Integer -> Integer
firstTriangleNumberOverNDivisors = head . triangleNumbersOverNDivisors

{-
  Optimize by not computing all the factors.
-}
triangleNumbersOverNDivisors :: Integer -> [Integer]
triangleNumbersOverNDivisors n =
  [t | t <- triangleNumbers, numDivisorsGreaterThan n t]

{-|
  Infinite stream of all the triangle numbers.
-}
triangleNumbers :: [Integer]
triangleNumbers = scanl1 (+) [1..]

{-
  Return whether the number of divisors of @t@ > @n@.
  Do this without actually calculating the number of divisors.
  Lazily pull from the stream of factor counts.
-}
numDivisorsGreaterThan :: Integer -> Integer -> Bool
numDivisorsGreaterThan _ 1 = False
numDivisorsGreaterThan n t =
  productGreaterThan n [m+1 | m <- factorCounts t]

{-
  Optimization to avoid computing full product if large.

  productGreaterThan n xs == product xs > n
-}
productGreaterThan :: Integer -> [Integer] -> Bool
productGreaterThan n xs = productAlreadyGreaterThan n 1 xs

{-
  Bail out early as soon as the partial product is already greater than
  @n@.
-}
productAlreadyGreaterThan :: Integer -> Integer -> [Integer] -> Bool
productAlreadyGreaterThan n = loop
  where loop prod [] = prod > n
        loop prod (x:xs)
          | prod' > n  = True
          | otherwise = loop prod' xs
            where prod' = prod*x

{-
  The number of divisors of @n@ does not actually require computation of
  the divisors. It only requires computation of the prime factors.
  For example, the factorization of 28 is 2, 2, 7.

  To clarify:

  2 has a count of 2 and 7 has a count of 1. Any divisor is a product
  of powers of the prime factors, from 0 to the count of each factor.

  Therefore, there are (2+1) * (1+1) == 6 divisors:

  2^0 * 7^0 == 1
  2^1 * 7^0 == 2
  2^2 * 7^0 == 4
  2^0 * 7^1 == 7
  2^1 * 7^1 = 14
  2^2 * 7^1 = 28

  This can still be improved, because our problem does not
  require computation of the number of divisors. It only requires
  checking whether the number is about to exceed a specified bound.

  See numDivisorsGreaterThan for improvement.
-}
numDivisors :: Integer -> Integer
numDivisors 1 = 1
numDivisors n = product [m+1 | m <- factorCounts n]

{-
  For each prime factor, return the number of times it occurs in @n@,
  which is assumed to be > 1.
-}
factorCounts :: Integer -> [Integer]
factorCounts = countDuplicates . factorStream

{-
  Utility function to group duplicates by their count.
  Optimizes what can be done with standard Prelude functions:

  countDuplicates xs == [length ys | ys <- List.group xs]
-}
countDuplicates :: Eq a => [a] -> [Integer]
countDuplicates []     = []
countDuplicates (x:xs) = countDuplicatesOf x 1 xs

{-
  Return possibly infinite stream of counts.
-}
countDuplicatesOf :: Eq a => a -> Integer -> [a] -> [Integer]
countDuplicatesOf _ count [] = [count]
countDuplicatesOf x count xs@(y:ys)
  | x == y    = countDuplicatesOf x (count+1) ys
  | otherwise = count : countDuplicatesOf y 1 ys

{-
  Factor @n@ using a given initial stream of factors to test.
-}
factorStream :: Integer -> [Integer]
factorStream = factorStreamFromStream possibleFactors

{-
  Return finite stream of one factor at a time of @n@ starting from
  a seed stream of possible factors. There may be duplicates, e.g.,
  28 is factored as [2, 2, 7].

  Non-primes in the candidate factor stream are skipped because
  we divide out factors as we see them.
-}
factorStreamFromStream :: [Integer] -> Integer -> [Integer]
factorStreamFromStream factors@(factor:moreFactors) n
  | factor*factor > n = [n]
  | otherwise =
    case n `quotRem` factor of
      (q, 0) -> factor : factorStreamFromStream factors q
      _      -> factorStreamFromStream moreFactors n
        

{-
  A stream of possible factors to consider.
  TODO: use a precomputed stream of primes?
-}
possibleFactors :: [Integer]
possibleFactors = 2 : [3, 5..]
